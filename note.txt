The only files to implement:
- libmfs.c
- server.c

Running & Testing

Server startup:
#1. Create a file system image: 

    Command: 
        gcc -o mkfs mkfs.c -Wall
        ./mkfs -f <image_file> [-d <num_data_blocks] [-i <num_inodes>]

    Description: 
        This runs mkfs.c to generate a on-disk file system image

#2. Run server:  
   
    Command: 
        server [portnum] [file-system-image]

    Description: 
        This creates a server using the file system image which acts as our disk

Client startup:
#3. Run client: 

    How:
        Call functions declared in libmfs.c in a main.c

    Description:
        Runs the client that communicates with the server.


Structs:

typedef struct {
	inode_t inodes[UFS_BLOCK_SIZE / sizeof(inode_t)];
} inode_block;

    typedef struct {
        int type;   // MFS_DIRECTORY or MFS_REGULAR
        int size;   // bytes
        unsigned int direct[DIRECT_PTRS]; // direct pointer to the block number, 30 different blocks locations to point to per file/ directory
    } inode_t; // 32 bytes

typedef struct {
	dir_ent_t entries[128]; // 4096/ 128 = 32 bytes per directory entry
} dir_block_t;

    // Which is true, each directory entry is indeed 32 bytes
    typedef struct {
        char name[28];  // up to 28 bytes of name in directory (including \0)
        int  inum;      // inode number of entry (-1 means entry not used)
    } dir_ent_t;

typedef struct {
	unsigned int bits[UFS_BLOCK_SIZE / sizeof(unsigned int)];
} bitmap_t;



lseek
char buf[SIZE]
fd = open("filename", O_RDWR)
read(fd, buf, SIZE); // it will read first SIZE char bytes into the buffer
lseek(fd, n, SEEK_CUR); // it will skip n items (including the last read item till SIZE)

- read is like a sliding window scan that moves to the next window of item








// Previously written run_lookup in server side

// Get the searched inode number
	int pinum = m->c_sent_inum;

	// INODE BITMAP
	// Gets inode bitmap's location
	char bufBlock[BLOCKSIZE];
	lseek(fd, SUPERBLOCKPTR->inode_bitmap_addr * BLOCKSIZE, SEEK_SET);
	read(fd, bufBlock, BLOCKSIZE);

	// Read inode bitmap AND get bit of inode
	unsigned int bitVal = get_bit((unsigned int*) bufBlock, pinum);

	// Check if inode is not found
	if(bitVal == 0)
		return -1;

	// INODE TABLE
	// Gets inode table's location
	lseek(fd, SUPERBLOCKPTR-> inode_region_addr * BLOCKSIZE, SEEK_SET);
	read(fd, bufBlock, BLOCKSIZE);

	// Read inode table block
	inode_block_t* inodeBlockPtr = (inode_block_t*) bufBlock; 
	
	// Read inode table and obtain inode
	inode_t inode = inodeBlockPtr->inodes[pinum];
	

	// DATA REGION
	// Iterate all potential 30 blocks where data is located
	for(int i = 0; i< DIRECT_PTRS; i++){
	
		// Gets data region direct data block index
		int directBlockNumber = inode.direct[i];

		// Gets directory entry block's location
		lseek(fd, directBlockNumber * BLOCKSIZE, SEEK_SET); // Does direct block number mean: directBlockNumber + SUPERBLOCKPTR->data_region_addr ??
		read(fd, bufBlock, BLOCKSIZE);
		
		// Read directory entry block
		dir_block_t* dirEntryBlockPtr = (dir_block_t*) bufBlock;
		
		// Read directory entry
		// Iterates all 128 directory entries in a directory entry block
		for(int j = 0; j< 128; j++){
			dir_ent_t dirEntry = dirEntryBlockPtr-> entries[j];
			if(strcmp(dirEntry.name, m->c_sent_name) == 0){
				m->c_received_inum = dirEntry.inum;
				return 0;
			}
		}
	}