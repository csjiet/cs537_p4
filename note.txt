The only files to implement:
- libmfs.c
- server.c

Running & Testing

Server startup:
#1. Create a file system image: 

    Command: 
        gcc -o mkfs mkfs.c -Wall
        ./mkfs -f <image_file> [-d <num_data_blocks] [-i <num_inodes>]

    Description: 
        This runs mkfs.c to generate a on-disk file system image

#2. Run server:  
   
    Command: 
        server [portnum] [file-system-image]

    Description: 
        This creates a server using the file system image which acts as our disk

Client startup:
#3. Run client: 

    How:
        Call functions declared in libmfs.c in a main.c

    Description:
        Runs the client that communicates with the server.


Structs:

typedef struct {
	inode_t inodes[UFS_BLOCK_SIZE / sizeof(inode_t)];
} inode_block;

    typedef struct {
        int type;   // MFS_DIRECTORY or MFS_REGULAR
        int size;   // bytes
        unsigned int direct[DIRECT_PTRS]; // direct pointer to the block number, 30 different blocks locations to point to per file/ directory
    } inode_t;

typedef struct {
	dir_ent_t entries[128]; // 4096/ 128 = 32 bytes per directory entry
} dir_block_t;

    // Which is true, each directory entry is indeed 32 bytes
    typedef struct {
        char name[28];  // up to 28 bytes of name in directory (including \0)
        int  inum;      // inode number of entry (-1 means entry not used)
    } dir_ent_t;

typedef struct {
	unsigned int bits[UFS_BLOCK_SIZE / sizeof(unsigned int)];
} bitmap_t;



lseek
char buf[SIZE]
fd = open("filename", O_RDWR)
read(fd, buf, SIZE); // it will read first SIZE char bytes into the buffer
lseek(fd, n, SEEK_CUR); // it will skip n items (including the last read item till SIZE)

- read is like a sliding window scan that moves to the next window of item




